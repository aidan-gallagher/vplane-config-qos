#!groovy

// Copyright (c) 2022. Ciena Corporation. All rights reserved.
// Copyright (c) 2020-2021, AT&T Intellectual Property. All rights reserved.
// SPDX-License-Identifier: GPL-2.0-only

// Developer---->|                    |----> External tool (eg. gitlint)
//               |----> makefile ---->|
// Jenkins ----->|                    |----> External tool (eg. mypy)
//
// To ensure a developer can run all the same checks that Jenkins performs the
// jenkinsfile should be a simple & thin wrapper that calls functionality in the makefile.


@NonCPS
def cancelPreviousBuilds() {
    def jobName = env.JOB_NAME
    def buildNumber = env.BUILD_NUMBER.toInteger()
    // Get job name
    def currentJob = Jenkins.instance.getItemByFullName(jobName)

    // Iterating over the builds for specific job
    for (def build : currentJob.builds) {
        // If there is a build that is currently running and it's not current build
        if (build.isBuilding() && build.number.toInteger() != buildNumber) {
            // Than stopping it
            build.doStop()
        }
    }
}

pipeline {

    agent {
        dockerfile true
    }

    options {
        quietPeriod(30) // Wait in case there are more SCM pushes/PR merges coming
        ansiColor('xterm')
    }

    stages {

        // A work around, until this feature is implemented: https://issues.jenkins-ci.org/browse/JENKINS-47503
        stage('Cancel older builds') { steps { script {
            cancelPreviousBuilds()
        }}}

        // Don't run package in parallel as I think the files generated by other stages breaks dpkg-buildpackage.
        stage('package') {
            steps {
                sh "make package"
            }
        }
        // Run lintian before pycache files are generated.
        stage('lintian') {
            steps {
                sh "make lintian"
            }
        }

        stage(' ') {
            parallel {
                stage('flake8') {
                    steps {
                            sh "make flake8"
                    }
                }
                stage('mypy') {
                    steps {
                            sh "make mypy"
                    }
                }
                stage(' ') {
                    stages {
                        stage('pytest') {
                            steps {
                                    sh "make pytest"
                            }
                        }
                        stage('coverage') {
                            steps {
                                    sh "make coverage"
                            }
                            post {
                                always {
                                    archiveArtifacts artifacts: 'htmlcov/', fingerprint: true
                                }
                            }
                        }
                    }
                }
                stage('gitlint') {
                    when {
                        // Only run on pull request because:
                        // * it would take long time to run over all commits.
                        // * if it did find errors we would not rewrite the master branch history to fix it
                        expression { env.CHANGE_TARGET != null }
                    }
                    steps {
                            sh "make gitlint commits=upstream/${env.CHANGE_TARGET}...origin/${env.BRANCH_NAME}"
                    }
                }
                stage('licence') {
                    when {
                        // Only run on pull request because it uses the current year to determine licence validity.
                        expression { env.CHANGE_TARGET != null }
                    }
                    steps {
                            sh "make licence commits=upstream/${env.CHANGE_TARGET}...origin/${env.BRANCH_NAME}"
                    }
                }
                stage('whitespace') {
                    when { // Only run on pull request because it would take too long to check every file.
                        expression { env.CHANGE_TARGET != null }
                    }
                    steps {
                            sh "make whitespace commits=upstream/${env.CHANGE_TARGET}...origin/${env.BRANCH_NAME}"
                    }
                }
                stage('perlcritic') {
                    steps {
                            sh script: "perlcritic --quiet --severity 5 . 2>&1 | tee perlcritic.txt", returnStatus: true
                    }
                    post {
                        always {
                                discoverGitReferenceBuild()
                                recordIssues tool: perlCritic(pattern: 'perlcritic.txt'),
                                    enabledForFailure: true,
                                    qualityGates: [[type: 'TOTAL', threshold: 10, unstable: true]]
                        }
                    }
                }
            } // parallel
        } // Stage ' '
    } // stages

    post {
        always {
            deleteDir()
        }
    }
}