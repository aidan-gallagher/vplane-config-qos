#!/usr/bin/env python3
"""
The Policy QoS VCI entrypoint module
"""
# Copyright (c) 2019-2020, AT&T Intellectual Property.
# All rights reserved.
#
# SPDX-License-Identifier: LGPL-2.1-only
#

import argparse
import logging
import logging.handlers
import sys

from copy import deepcopy
from traceback import format_tb
from systemd.journal import JournalHandler

import vci

from vplaned import Controller, ControllerException

from vyatta_policy_qos_vci.provisioner import Provisioner
from vyatta_policy_qos_vci.provisioner import get_requested_config
from vyatta_policy_qos_vci.provisioner import get_actioned_config
from vyatta_policy_qos_vci.provisioner import save_requested_config
from vyatta_policy_qos_vci.provisioner import save_actioned_config
from vyatta_policy_qos_vci.qos_op_mode import convert_if_list


def remove_deferred_ingress_maps(config, deferred_in_map_list):
    """
    Delete any deferred ingress-maps from the JSON config dictionary.
    """
    policy_dict = config.get('vyatta-policy-v1:policy')
    if policy_dict is None:
        return

    in_map_list = policy_dict.get('vyatta-policy-qos-v1:ingress-map')
    if in_map_list is None:
        return

    for in_map_name in deferred_in_map_list:
        for index, in_map_dict in enumerate(in_map_list):
            if in_map_dict['id'] == in_map_name:
                del in_map_list[index]
                break


def send_qos_config_to_dataplane(new_config):
    """
    We are now ready to send the QoS configuration down to the vyatta-dataplane.
    """
    try:
        actioned_config = get_actioned_config()
        LOG.debug(f'actioned-config: {actioned_config}')
        LOG.debug(f'new-config:      {new_config}')
        prov = Provisioner(actioned_config, new_config)
        with Controller() as ctrl:
            prov.commands(ctrl)
            save_requested_config(new_config)

        LOG.debug(f"deferred ingress-maps: {prov.deferred_ingress_maps}")
        # Copy the requested config, then remove any deferred ingress maps, then
        # save it as the actioned config.
        actioned_config = deepcopy(new_config)
        remove_deferred_ingress_maps(actioned_config,
                                     prov.deferred_ingress_maps)
        save_actioned_config(actioned_config)

    except ControllerException:
        LOG.error("Failed to connect to vplane-controller")

    except Exception:
        tb_type = sys.exc_info()[0]
        tb_value = sys.exc_info()[1]
        tb_info = format_tb(sys.exc_info()[2])
        tb_output = ""
        for line in tb_info:
            tb_output += line

        LOG.error(f"Unhandled exception: {tb_type}\n{tb_value}\n{tb_output}")

    return actioned_config


class Config(vci.Config):
    """
    The Configuration mode class for QoS VCI
    """
    config = {}
    def set(self, new_config):
        """
        Update the QoS config down in the dataplane from the VCI JSON
        """
        LOG.debug(f"Config:set - {new_config}")

        # Issue the required NPF and QoS commands, and save the actioned
        # configuration
        self.config = send_qos_config_to_dataplane(new_config)
        return

    def get(self):
        """ What do we need to put in here? """
        LOG.debug("Config:get")
        # If the QoS VCI process has been restarted we may an empty self.config
        # in which case we need to read the current config from the
        # saved-actioned config file.
        if self.config:
            self.config = get_actioned_config()

        return self.config

    def check(self, _):
        """ Move the validation checks from perl to here? """
        LOG.debug("Config:check")
        return


class State(vci.State):
    """
    The Operational mode class for QoS VCI
    """
    def get(self):
        """
        Ask the vyatta-dataplane to generate the JSON for the
        current QoS state and return it
        """
        try:
            op_mode_state = None
            with Controller() as ctrl:
                for dataplane in ctrl.get_dataplanes():
                    with dataplane:
                        op_mode_state = dataplane.json_command("qos optimised-show")

            yang_state = {}
            if op_mode_state is not None:
                if_list = convert_if_list("all", op_mode_state)
                if if_list:
                    yang_state["if-list"] = if_list

            # We must include the namespace at the top level, and everywhere
            # that the namespace changes
            if not yang_state:
                return {}

        except ControllerException:
            LOG.error("Failed to connect to vplane-controller")

        except Exception:
            tb_type = sys.exc_info()[0]
            tb_value = sys.exc_info()[1]
            tb_info = format_tb(sys.exc_info()[2])
            tb_output = ""
            for line in tb_info:
                tb_output += line

            LOG.error(f"Unhandled exception: {tb_type}\n{tb_value}\n{tb_output}")

        return {'vyatta-policy-v1:policy': {'vyatta-policy-qos-v1:qos':
                                            {'state': yang_state}}}


if __name__ == "__main__":
    try:
        PARSER = argparse.ArgumentParser(description='Policy QoS VCI Service')
        PARSER.add_argument('--debug', action='store_true', help='Enabled debugging')
        ARGS = PARSER.parse_args()

        logging.root.addHandler(JournalHandler(SYSLOG_IDENTIFIER='vyatta-policy-qos-vci'))
        LOG = logging.getLogger('Policy QoS VCI')

        if ARGS.debug:
            LOG.setLevel(logging.DEBUG)
            LOG.debug("Debug enabled")

        qos_config = None

        LOG.debug("About to register with VCI")

        (vci.Component("net.vyatta.vci.policy.qos")
         .model(vci.Model("net.vyatta.vci.policy.qos.v1")
                .config(Config())
                .state(State())
               )
         .run()
         .wait())

    except:
        LOG.error(f"Unexpected error: {sys.exc_info()[0]}")
