#!/usr/bin/env python3
"""
The Policy QoS VCI entrypoint module
"""
# Copyright (c) 2019, AT&T Intellectual Property.
# All rights reserved.
#
# SPDX-License-Identifier: LGPL-2.1-only
#

import argparse
import logging
import logging.handlers
import sys

from copy import deepcopy
from systemd.journal import JournalHandler

import vci

from vplaned import Controller, ControllerException

from vyatta_policy_qos_vci.provisioner import Provisioner
from vyatta_policy_qos_vci.provisioner import get_requested_config
from vyatta_policy_qos_vci.provisioner import get_actioned_config
from vyatta_policy_qos_vci.provisioner import save_requested_config
from vyatta_policy_qos_vci.provisioner import save_actioned_config
from vyatta_policy_qos_vci.qos_op_mode import convert_if_list


def remove_deferred_interfaces(config, deferred_if_list):
    """
    Remove all references to interface names listed in the deferred_if_list
    from the JSON config dictionary.
    """
    for ifname in deferred_if_list:
        if_dict = config.get('vyatta-interfaces-v1:interfaces')
        if if_dict:
            for if_type_list in if_dict.values():
                for index, if_type_dict in enumerate(if_type_list):
                    for value in if_type_dict.values():
                        if value == ifname:
                            del if_type_list[index]
                            break


def send_qos_config_to_dataplane(new_config):
    """
    We are now ready to send the QoS configuration down to the vyatta-dataplane.
    """
    global deferred_interfaces

    actioned_config = get_actioned_config()
    prov = Provisioner(actioned_config, new_config)
    try:
        with Controller() as ctrl:
            prov.commands(ctrl)
            save_requested_config(new_config)

    except ControllerException:
        LOG.error("Failed to connect to vplane-controller")

    LOG.debug(f"deferred interfaces: {prov.deferred_interfaces}")
    # Copy the requested config, then remove any deferred interface, then
    # save it as the actioned config.
    actioned_config = deepcopy(new_config)
    remove_deferred_interfaces(actioned_config, prov.deferred_interfaces)
    save_actioned_config(actioned_config)

    return actioned_config


def if_plug_unplug(notification):
    """
    Called whenever a deferred interface gets plugged in or out.
    On software VMs, tunnels are deferred interfaces, but dataplane
    interfaces are not.  On VNF systems, vhost interfaces are also deferred.
    On hardware platforms, both tunnels and dataplane interfaces are deferred.
    """
    global deferred_interfaces

    LOG.debug(f"if-plug-unplug: {notification}")
    if_name = notification['vyatta-ifmgr-v1:interface']['name']
    if_state = notification['vyatta-ifmgr-v1:interface']['state']

    if if_name in deferred_interfaces:
        if if_state == 'plugged':
            # We have a new interface to configure
            deferred_interfaces.remove(if_name)

            # At this point we need to compare the saved-requested verses the
            # saved-actioned configs.  The saved-requested should have the
            # recently plugged-in interface, the saved-actioned config won't.
            requested_config = get_requested_config()
            send_qos_config_to_dataplane(requested_config)


class Config(vci.Config):
    """
    The Configuration mode class for QoS VCI
    """
    config = {}
    def set(self, new_config):
        """
        Update the QoS config down in the dataplane from the VCI JSON
        """
        LOG.debug(f"Config:set - {new_config}")

        # Issue the required NPF and QoS commands, and save the actioned
        # configuration
        self.config = send_qos_config_to_dataplane(new_config)
        return

    def get(self):
        """ What do we need to put in here? """
        LOG.debug("Config:get")
        return self.config

    def check(self, _):
        """ Move the validation checks from perl to here? """
        LOG.debug("Config:check")
        return


class State(vci.State):
    """
    The Operational mode class for QoS VCI
    """
    def get(self):
        """
        Ask the vyatta-dataplane to generate the JSON for the
        current QoS state and return it
        """
        op_mode_state = None
        with Controller() as ctrl:
            for dataplane in ctrl.get_dataplanes():
                with dataplane:
                    op_mode_state = dataplane.json_command("qos optimised-show")

        yang_state = {}
        if op_mode_state is not None:
            if_list = convert_if_list("all", op_mode_state)
            if if_list:
                yang_state["if-list"] = if_list

        # We must include the namespace at the top level, and everywhere that
        # the namespace changes
        if not yang_state:
            return {}

        return {'vyatta-policy-v1:policy': {'vyatta-policy-qos-v1:qos':
                                            {'state': yang_state}}}


if __name__ == "__main__":
    try:
        PARSER = argparse.ArgumentParser(description='Policy QoS VCI Service')
        PARSER.add_argument('--debug', action='store_true', help='Enabled debugging')
        ARGS = PARSER.parse_args()

        logging.root.addHandler(JournalHandler(SYSLOG_IDENTIFIER='vyatta-policy-qos-vci'))
        LOG = logging.getLogger('Policy QoS VCI')

        if ARGS.debug:
            LOG.setLevel(logging.DEBUG)
            LOG.debug("Debug enabled")

        qos_config = None
        deferred_interfaces = []

        LOG.debug("About to register with VCI")

        (vci.Component("net.vyatta.vci.policy.qos")
         .model(vci.Model("net.vyatta.vci.policy.qos.v1")
                .config(Config())
                .state(State())
               )
#         .subscribe("vyatta-npf-v1", "configuration-updated", npf_update)
         .subscribe("vyatta-ifmgr-v1", "interface-state", if_plug_unplug)
         .run()
         .wait())

    except:
        LOG.error(f"Unexpected error: {sys.exc_info()[0]}")
